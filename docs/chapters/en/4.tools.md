# Chapter 4: Tools

## 4.1 Regex patterns

- IP regex pattern: `((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}`
- All words in quote block: `"(.*?)"`

## 4.2 [jq](https://jqlang.github.io/jq/manual/)

> A CLI tools that processing JSON data

### 4.2.1 JQ Syntax

| Syntax |                              Description                               |
| ------ | :--------------------------------------------------------------------: |
|        | Filters separated by a comma will produce multiple independent outputs |
| ?      |              Will ignores error if the type is unexpected              |
| []     |                           Array construction                           |
| {}     |                          Object construction                           |
| +      |                           Concatenate or Add                           |
| -      |                    Difference of sets or Substract                     |
| length |                        Size of selected element                        |
| \|     |    Pipes are used to chain commands in a similar fashion than bash     |

### 4.2.2 JQ Built-ins

| -             | -         | -          | -        | -          | -            | -              | -          | -          | -                 |
| ------------- | --------- | ---------- | -------- | ---------- | ------------ | -------------- | ---------- | ---------- | ----------------- |
| abs           | add       | all        | and      | any        | arrays       | booleans       | bsearch    | capture    | combinations      |
| contains      | debugs    | del        | delpath  | empty      | endswith     | env            | error      | explode    | finites           |
| first         | first     | flatten    | floor    | foreach    | from_entries | getpath        | group_by   | gsub       | halt              |
| halt_error    | has       | implode    | in       | index      | indices      | infinite       | input      | input_file | input_line_number |
| inputs        | inside    | isempty    | isfinite | isinfinite | isnan        | isnormal       | iterables  | join       | keys              |
| keys_unsorted | last      | last       | length   | limit      | ltrimstr     | map            | map_values | match      | max               |
| max_by        | min       | min_by     | nan      | normals    | not          | nth            | nth        | nulls      | numbers           |
| objects       | or        | path       | paths    | pick       | range        | recurse        | reduce     | repeat     | reverse           |
| rindex        | rtrimstr  | scalars    | scan     | select     | setpath      | sort           | sort_by    | split      | split             |
| splits        | sqrt      | startswith | stderr   | strings    | sub          | test           | to_entries | tonumber   |
| tostring      | transpose | type       | unique   | unique_by  | until        | utf8bytelength | values     | walk       | while             |
| with_entries  |

### 4.2.3 Basic

- Format JSON data:

  ```bash
  data='{"name": "foo"}'; echo $data | jq .
  ```

- List JSON object keys as array:

  ```bash
  data='{"id": 1 "name": "foo"}'; echo $data | jq 'keys'
  ```

- Count array length:

  ```bash
  data='[{"name": "foo"} {"name": "bar"}]'; echo $data | jq 'length'
  ```

**1. Dealing with JSON objects**

- Output selected JSON data:

  ```bash
  data='{"id": 1 "name": "foo" "phone": 0123 "address": "here"}';
  echo $data | jq '{name id}'

  # rename object value
  data='{"id": 1 "name": "foo" "phone": 0123 "address": "here"}';
  echo $data | jq '{ID: .id Name: .name}'

  # deleted object value
  data='{"id": 1 "name": "foo" "phone": 0123 "address": "here"}';
  echo $data | jq 'del(.phone .address)'
  ```

- Convert object keys values to array:

  ```bash
  data='{"id": 1 "name": "foo" "phone": 0123 "address": "here"}';
  echo $data | jq 'to_entries | map(.key .value)'
  ```

- Convert nested object to new object:

  ```bash
  data='{"id": 1 "name": "foo" "favorite": [{"type": "food" "name": "beef"} {"type": "beverage" "name": "beer"}]}';
  echo $data | jq '{Name: .name} + (.favorite[] | {FavType: .type FavName: .name})'
  ```

- Convert nested object to new object with condition:

  ```bash
  data='{"id": 1 "name": "foo" "favorite": [{"type": "food" "name": "beef"} {"type": "food" "name": "lamb"} {"type": "beverage" "name": "beer"}]}';
  echo $data | jq '{Name: .name} + (.favorite[] | select(.type=="food") | {FavType: .type FavName: .name})'
  ```

- Merge 2 JSON objects in 2 files:

  ```bash
  echo '{"id": 1 "name": "foo}' > example_1.json
  echo '{"address": "bar"}' > example_2.json
  jq -s '.[0] * .[1]' example_1.json example_2.json # {id: 1 name: foo address: bar}
  ```

**2. Dealing JSON array**

- Filter array object with condition:

  ```bash
  # `or` condition
  data='[{"id": 1 "name": "foo"} {"id": 2 "name": "bar"} {"id": 3 "name": "fas"}]';
  echo $data | jq -r '[ .[] | select((.name=="foo") or .id==2) ]'

   # `and` condition
  data='[{"id": 1 "name": "foo"} {"id": 2 "name": "bar"} {"id": 3 "name": "fas"}]';
  echo $data | jq -r '[ .[] | select((.name=="foo") and .id==1) ]'
  ```

- Concate string on array

  ```bash
  data='[{"id": 1 "firstName": "Foo" "lastName": "Bar"},{"id": 2 "firstName": "Bob" "lastName": "Alice"}]';
  echo $data | jq -r '[ .[] | {id: .id Name: (.firstName + " " + .lastName) } ]'
  ```

- Flatten array
  ```bash
  data='{"id": 1 "name": "foo" "favorite": [{"type": "food" "name": "beef"} {"type": "food" "name": "lamb"} {"type": "beverage" "name": "beer"}]}'; echo $data | jq 'flatten'
  ```

## 4.3 [trdsql](https://noborus.github.io/trdsql/)

> A CLI tool that executes SQL on CSV, LTSV, JSON, YAML, TBLN files
